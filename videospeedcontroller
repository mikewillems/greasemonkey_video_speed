// ==UserScript==
// @name         Video Speed Controls
// @namespace    http://github.com/mikewillems/greasemonkey_video_speed
// @version      0.4
// @description  Speed controller overlay with fade in/out on focus/changes or mouseover, which only runs on chosen sites.
// @match        *://www.youtube.com/*
// @match        *://youtube.com/*
// @match        *://www.vimeo.com/*
// @match        *://vimeo.com/*
// @match        *://www.dailymotion.com/*
// @match        *://dailymotion.com/*
// @match        *://www.tiktok.com/*
// @match        *://tiktok.com/*
// @match        *://www.instagram.com/*
// @match        *://instagram.com/*
// @match        *://www.twitter.com/*
// @match        *://twitter.com/*
// @match        *://x.com/*
// @match        *://www.x.com/*
// @match        *://www.reddit.com/*
// @match        *://reddit.com/*
// @match        *://www.bilibili.com/*
// @match        *://bilibili.com/*
// @match        *://www.veoh.com/*
// @match        *://veoh.com/*
// @match        *://www.metacafe.com/*
// @match        *://metacafe.com/*
// @match        *://www.liveleak.com/*
// @match        *://liveleak.com/*
// @match        *://www.archive.org/*
// @match        *://archive.org/*
// @match        *://www.vidyard.com/*
// @match        *://vidyard.com/*
// @match        *://www.wistia.com/*
// @match        *://wistia.com/*
// @match        *://www.dtube.video/*
// @match        *://dtube.video/*
// @match        *://www.rumble.com/*
// @match        *://rumble.com/*
// @match        *://www.odyssey.com/*
// @match        *://odyssey.com/*
// @match        *://odysee.com/*
// @match        *://www.odysee.com/*
// @run-at       document-end
// @grant        GM_addStyle
// ==/UserScript==

(function() {
    'use strict';

console.log('[VideoSpeedCtrl] Script loaded on', window.location.href);

// ----- Config -----
const BIG_INCREMENTS = [0.125, 0.25, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0];
const SMALL_INC_RANGE = [0.1, 6.0];
const SHOW_DURATION_MS = 1000;
const FADE_DURATION_MS = 1000;

// ----- State -----
let currentVideo = null;
let controllerBox = null;
let setButton = null;

// timers for fade logic
let hideTimeout = null;
let finalHideTimeout = null;
let overlayHover = false;

// track all known video elements for geometric hover detection
const videoElements = new Set();

// ----- Helpers -----
function clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
}

function roundToTwoDecimals(value) {
    return Math.round(value * 100) / 100;
}

function setPlaybackRate(video, rate) {
    let newRate = clamp(rate, SMALL_INC_RANGE[0], SMALL_INC_RANGE[1]);
    newRate = roundToTwoDecimals(newRate);
    video.playbackRate = newRate;
    updateSetButtonLabel();
    // console.log('[VideoSpeedCtrl] playbackRate =>', newRate);
}

function showOverlay() {
    if (!controllerBox) return;

    // cancel any pending hides
    if (hideTimeout) {
        clearTimeout(hideTimeout);
        hideTimeout = null;
    }
    if (finalHideTimeout) {
        clearTimeout(finalHideTimeout);
        finalHideTimeout = null;
    }

    controllerBox.style.display = 'flex';
    // force reflow so transition definitely applies
    // eslint-disable-next-line no-unused-expressions
    controllerBox.offsetHeight;

    controllerBox.classList.add('gm-visible');

    // If we're currently hovering the overlay, never schedule auto-hide.
    if (overlayHover) {
        return;
    }

    hideTimeout = setTimeout(() => {
        controllerBox.classList.remove('gm-visible');
        finalHideTimeout = setTimeout(() => {
            if (!controllerBox.classList.contains('gm-visible')) {
                controllerBox.style.display = 'none';
            }
        }, FADE_DURATION_MS);
    }, SHOW_DURATION_MS);
}

// ----- Step Logic -----
function bigStepDown(video) {
    const current = video.playbackRate || 1.0;
    let target = current;
    for (let i = BIG_INCREMENTS.length - 1; i >= 0; i--) {
        if (BIG_INCREMENTS[i] < current) {
            target = BIG_INCREMENTS[i];
            break;
        }
    }
    setPlaybackRate(video, target);
}

function bigStepUp(video) {
    const current = video.playbackRate || 1.0;
    let target = current;
    for (let i = 0; i < BIG_INCREMENTS.length; i++) {
        if (BIG_INCREMENTS[i] > current) {
            target = BIG_INCREMENTS[i];
            break;
        }
    }
    setPlaybackRate(video, target);
}

function smallStepDown(video) {
    const current = video.playbackRate || 1.0;
    const min = SMALL_INC_RANGE[0];
    let target = Math.floor(current * 10 - 0.0001) / 10; // highest 0.1 multiple < current
    if (target < min) target = min;
    setPlaybackRate(video, target);
}

function smallStepUp(video) {
    const current = video.playbackRate || 1.0;
    const max = SMALL_INC_RANGE[1];
    let target = Math.ceil(current * 10 + 0.0001) / 10; // lowest 0.1 multiple > current
    if (target > max) target = max;
    setPlaybackRate(video, target);
}

function setToDefault(video) {
    setPlaybackRate(video, 1.0);
}

// ----- Controller UI -----
function injectStyles() {
    const css = `
        #gm-video-speed-controller {
            position: fixed;
            bottom: 16px;
            right: 16px;
            z-index: 999999;
            /* border: 4px solid red; /* for testing */
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px;
            border-radius: 6px;
            font-family: sans-serif;
            font-size: 12px;
            display: none; /* hidden by default */
            gap: 6px;
            align-items: center;
            opacity: 0;
            transition: opacity ${FADE_DURATION_MS}ms ease-out;
        }
        #gm-video-speed-controller.gm-visible {
            opacity: 1;
        }
        #gm-video-speed-controller .gm-btn {
            border: 1px solid rgba(255,255,255,0.6);
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            user-select: none;
            min-width: 24px;
            text-align: center;
        }
        #gm-video-speed-controller .gm-btn:hover {
            background: rgba(255,255,255,0.2);
        }
    `;
    if (typeof GM_addStyle === 'function') {
        GM_addStyle(css);
    } else {
        const style = document.createElement('style');
        style.textContent = css;
        document.head.appendChild(style);
    }
}

function createController() {
    if (controllerBox) return controllerBox;

    injectStyles();

    controllerBox = document.createElement('div');
    controllerBox.id = 'gm-video-speed-controller';

    const label = document.createElement('span');
    label.textContent = 'Speed:';

    const btnLabels = ['<<', '<', 'set', '>', '>>'];
    const buttons = {};

    btnLabels.forEach(text => {
        const b = document.createElement('div');
        b.className = 'gm-btn';
        b.textContent = text;
        buttons[text] = b;
        controllerBox.appendChild(b);
    });

    controllerBox.insertBefore(label, controllerBox.firstChild);

    buttons['<<'].addEventListener('click', () => {
        if (!currentVideo) return;
        bigStepDown(currentVideo);
        showOverlay();
    });

    buttons['<'].addEventListener('click', () => {
        if (!currentVideo) return;
        smallStepDown(currentVideo);
        showOverlay();
    });

    buttons['set'].addEventListener('click', () => {
        if (!currentVideo) return;
        setToDefault(currentVideo);
        showOverlay();
    });

    buttons['>'].addEventListener('click', () => {
        if (!currentVideo) return;
        smallStepUp(currentVideo);
        showOverlay();
    });

    buttons['>>'].addEventListener('click', () => {
        if (!currentVideo) return;
        bigStepUp(currentVideo);
        showOverlay();
    });

    setButton = buttons['set'];

    document.body.appendChild(controllerBox);
    console.log('[VideoSpeedCtrl] Controller injected');

    updateSetButtonLabel();
    return controllerBox;
}

function updateSetButtonLabel() {
    if (!setButton) return;
    let speed = 1.0;
    if (currentVideo) {
        speed = currentVideo.playbackRate || 1.0;
    }
    const rounded = roundToTwoDecimals(speed).toFixed(2);
    setButton.textContent = `${rounded}x`;
}

// ----- Video tracking -----
function markVideoActive(video) {
    currentVideo = video;
    if (!video.hasAttribute('tabindex')) {
        video.setAttribute('tabindex', '0');
    }
    updateSetButtonLabel();
    // console.log('[VideoSpeedCtrl] Active video set', video);
    showOverlay();
}

function attachToVideo(video) {
    if (video.__gmSpeedAttached) return;
    video.__gmSpeedAttached = true;

    videoElements.add(video);

    video.addEventListener('click', () => markVideoActive(video));
    video.addEventListener('focus', () => markVideoActive(video));
    video.addEventListener('playing', () => markVideoActive(video));
    video.addEventListener('ratechange', () => {
        if (currentVideo === video) {
            updateSetButtonLabel();
        }
    });

    if (!currentVideo) {
        markVideoActive(video);
    }
}

function scanForVideos() {
    const videos = document.querySelectorAll('video');
    videos.forEach(v => attachToVideo(v));
}

// ----- Keyboard shortcuts -----
window.addEventListener('keydown', function(e) {
    if (!currentVideo) return;

    const target = e.target;
    const tag = target && target.tagName ? target.tagName.toLowerCase() : '';
    if (['input', 'textarea', 'select'].includes(tag) || target.isContentEditable) {
        return;
    }

    const active = document.activeElement;
    const overlayHasFocus = controllerBox && controllerBox.contains(active);
    const videoHasFocus = (active === currentVideo);
    // If you want strictly "video in focus", uncomment:
    // if (!videoHasFocus && !overlayHasFocus) return;

    let handled = false;
    switch (e.key) {
        case 'S':
            bigStepDown(currentVideo);
            handled = true;
            break;
        case 's':
            smallStepDown(currentVideo);
            handled = true;
            break;
        case 'o':
            setToDefault(currentVideo);
            handled = true;
            break;
        case 'd':
            smallStepUp(currentVideo);
            handled = true;
            break;
        case 'D':
            bigStepUp(currentVideo);
            handled = true;
            break;
    }

    if (handled) {
        e.preventDefault();
        e.stopPropagation();
        showOverlay();
    }
}, true);

// ----- Global mousemove: geometry-based hit test -----
window.addEventListener('mousemove', function(e) {
    const x = e.clientX;
    const y = e.clientY;

    // 1) First, see if we're over the overlay itself
    let inOverlay = false;
    if (controllerBox && controllerBox.style.display !== 'none') {
        const orect = controllerBox.getBoundingClientRect();
        if (
            x >= orect.left &&
            x <= orect.right &&
            y >= orect.top &&
            y <= orect.bottom
        ) {
            inOverlay = true;
        }
    }

    if (inOverlay) {
        // Pointer is inside overlay region: pin it visible.
        if (!overlayHover) {
            overlayHover = true;
            // Kill any pending hides and make sure it's visible.
            if (hideTimeout) {
                clearTimeout(hideTimeout);
                hideTimeout = null;
            }
            if (finalHideTimeout) {
                clearTimeout(finalHideTimeout);
                finalHideTimeout = null;
            }
            controllerBox.style.display = 'flex';
            controllerBox.classList.add('gm-visible');
        }
        return; // don't treat this as video hover
    } else {
        // If we were hovering overlay and just left it, start the normal hide cycle.
        if (overlayHover) {
            overlayHover = false;
            showOverlay(); // schedules hide timers from "now"
        }
    }

    // 2) If not over overlay, see if we're over any tracked <video>
    if (videoElements.size === 0) return;

    let hoveredVideo = null;
    for (const v of videoElements) {
        const rect = v.getBoundingClientRect();
        if (
            x >= rect.left &&
            x <= rect.right &&
            y >= rect.top &&
            y <= rect.bottom
        ) {
            hoveredVideo = v;
            break;
        }
    }

    if (!hoveredVideo) return;

    // Pointer is within the bounding box of a <video>; treat as hover
    markVideoActive(hoveredVideo);
    // markVideoActive already calls showOverlay(), which will
    // schedule hide timers (since overlayHover is false here).
}, true);

// ----- Startup -----
createController();
scanForVideos();
showOverlay(); // initial show on load

const observer = new MutationObserver(() => scanForVideos());
observer.observe(document.documentElement || document.body, {
    childList: true,
    subtree: true
});

})();
