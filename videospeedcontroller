// ==UserScript==
// @name         Video Speed Controls
// @namespace    http://github.com/mikewillems/greasemonkey_video_speed
// @version      0.4
// @description  Speed controller overlay with fade in/out on focus/changes or mouseover, which only runs on chosen sites.
// @match        *://www.youtube.com/*
// @match        *://youtube.com/*
// @match        *://www.vimeo.com/*
// @match        *://vimeo.com/*
// @match        *://www.dailymotion.com/*
// @match        *://dailymotion.com/*
// @match        *://www.tiktok.com/*
// @match        *://tiktok.com/*
// @match        *://www.instagram.com/*
// @match        *://instagram.com/*
// @match        *://www.twitter.com/*
// @match        *://twitter.com/*
// @match        *://x.com/*
// @match        *://www.x.com/*
// @match        *://www.reddit.com/*
// @match        *://reddit.com/*
// @match        *://www.bilibili.com/*
// @match        *://bilibili.com/*
// @match        *://www.veoh.com/*
// @match        *://veoh.com/*
// @match        *://www.metacafe.com/*
// @match        *://metacafe.com/*
// @match        *://www.liveleak.com/*
// @match        *://liveleak.com/*
// @match        *://www.archive.org/*
// @match        *://archive.org/*
// @match        *://www.vidyard.com/*
// @match        *://vidyard.com/*
// @match        *://www.wistia.com/*
// @match        *://wistia.com/*
// @match        *://www.dtube.video/*
// @match        *://dtube.video/*
// @match        *://www.rumble.com/*
// @match        *://rumble.com/*
// @match        *://www.odyssey.com/*
// @match        *://odyssey.com/*
// @match        *://odysee.com/*
// @match        *://www.odysee.com/*
// @run-at       document-end
// @grant        GM_addStyle
// ==/UserScript==
(function() {
    'use strict';

    console.log('[VideoSpeedCtrl] Script loaded on', window.location.href);

    // ----- Config -----
    const BIG_INCREMENTS = [0.125, 0.25, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0];
    const SMALL_INC_RANGE = [0.1, 6.0];
    const SHOW_DURATION_MS = 1000;
    const FADE_DURATION_MS = 1000;

    // Oscillation timing (ms)
    const OSC_UP_MS = 5000;
    const OSC_HOLD_MAX_MS = 1000;
    const OSC_DOWN_MS = 5000;
    const OSC_HOLD_MIN_MS = 1000;
    const OSC_TOTAL_MS = OSC_UP_MS + OSC_HOLD_MAX_MS + OSC_DOWN_MS + OSC_HOLD_MIN_MS;

    // ----- State -----
    let currentVideo = null;
    let controllerBox = null;
    let setButton = null;

    let hideTimeout = null;
    let finalHideTimeout = null;
    let overlayHover = false;

    const videoElements = new Set();

    // --- oscillation state ---
    let oscillationActive = false;
    let oscillationTimer = null;
    let oscillationStartTime = 0;
    let oscillationMin = 1.0;
    let oscillationMax = 2.0;

    // ----- Helpers -----
    function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
    }

    function roundToTwoDecimals(value) {
        return Math.round(value * 100) / 100;
    }

    function setPlaybackRate(video, rate) {
        let newRate = clamp(rate, SMALL_INC_RANGE[0], SMALL_INC_RANGE[1]);
        newRate = roundToTwoDecimals(newRate);
        video.playbackRate = newRate;
        updateSetButtonLabel();
    }

    // Manual changes should stop oscillation
    function setPlaybackRateManual(video, rate) {
        stopOscillation();
        setPlaybackRate(video, rate);
    }

    function showOverlay() {
        if (!controllerBox) return;

        if (hideTimeout) {
            clearTimeout(hideTimeout);
            hideTimeout = null;
        }
        if (finalHideTimeout) {
            clearTimeout(finalHideTimeout);
            finalHideTimeout = null;
        }

        controllerBox.style.display = 'flex';
        // force reflow
        // eslint-disable-next-line no-unused-expressions
        controllerBox.offsetHeight;

        controllerBox.classList.add('gm-visible');

        // while hovering overlay, never auto-hide
        if (overlayHover) return;

        hideTimeout = setTimeout(() => {
            controllerBox.classList.remove('gm-visible');
            finalHideTimeout = setTimeout(() => {
                if (!controllerBox.classList.contains('gm-visible')) {
                    controllerBox.style.display = 'none';
                }
            }, FADE_DURATION_MS);
        }, SHOW_DURATION_MS);
    }

    // ----- Step Logic -----
    function bigStepDown(video) {
        const current = video.playbackRate || 1.0;
        let target = current;
        for (let i = BIG_INCREMENTS.length - 1; i >= 0; i--) {
            if (BIG_INCREMENTS[i] < current) {
                target = BIG_INCREMENTS[i];
                break;
            }
        }
        setPlaybackRateManual(video, target);
    }

    function bigStepUp(video) {
        const current = video.playbackRate || 1.0;
        let target = current;
        for (let i = 0; i < BIG_INCREMENTS.length; i++) {
            if (BIG_INCREMENTS[i] > current) {
                target = BIG_INCREMENTS[i];
                break;
            }
        }
        setPlaybackRateManual(video, target);
    }

    function smallStepDown(video) {
        const current = video.playbackRate || 1.0;
        const min = SMALL_INC_RANGE[0];
        let target = Math.floor(current * 10 - 0.0001) / 10; // highest 0.1 multiple < current
        if (target < min) target = min;
        setPlaybackRateManual(video, target);
    }

    function smallStepUp(video) {
        const current = video.playbackRate || 1.0;
        const max = SMALL_INC_RANGE[1];
        let target = Math.ceil(current * 10 + 0.0001) / 10; // lowest 0.1 multiple > current
        if (target > max) target = max;
        setPlaybackRateManual(video, target);
    }

    function setToDefault(video) {
        setPlaybackRateManual(video, 1.0);
    }

    // ----- Oscillation -----
    function startOscillation() {
        if (!currentVideo) return;

        const cur = currentVideo.playbackRate || 1.0;
        let min = Math.min(cur, 2.0);
        let max = Math.max(cur, 2.0);

        min = clamp(min, SMALL_INC_RANGE[0], SMALL_INC_RANGE[1]);
        max = clamp(max, SMALL_INC_RANGE[0], SMALL_INC_RANGE[1]);

        if (min === max) {
            // nothing to oscillate between
            return;
        }

        oscillationMin = min;
        oscillationMax = max;
        oscillationStartTime = performance.now();
        oscillationActive = true;

        if (oscillationTimer) clearInterval(oscillationTimer);
        oscillationTimer = setInterval(updateOscillation, 100);
        updateOscillation();
        showOverlay();
    }

    function stopOscillation() {
        if (!oscillationActive) return;
        oscillationActive = false;
        if (oscillationTimer) {
            clearInterval(oscillationTimer);
            oscillationTimer = null;
        }
    }

    function updateOscillation() {
        if (!oscillationActive || !currentVideo) {
            stopOscillation();
            return;
        }

        const now = performance.now();
        let t = (now - oscillationStartTime) % OSC_TOTAL_MS;

        let rate;
        if (t < OSC_UP_MS) {
            // ramp up from min to max over 5s
            const f = t / OSC_UP_MS;
            rate = oscillationMin + (oscillationMax - oscillationMin) * f;
        } else if (t < OSC_UP_MS + OSC_HOLD_MAX_MS) {
            // hold max
            rate = oscillationMax;
        } else if (t < OSC_UP_MS + OSC_HOLD_MAX_MS + OSC_DOWN_MS) {
            // ramp down from max to min
            const tDown = t - (OSC_UP_MS + OSC_HOLD_MAX_MS);
            const f = tDown / OSC_DOWN_MS;
            rate = oscillationMax - (oscillationMax - oscillationMin) * f;
        } else {
            // hold min
            rate = oscillationMin;
        }

        setPlaybackRate(currentVideo, rate);
        // don't spam showOverlay() here; rely on the initial show when 'v' is pressed
    }

    // ----- Controller UI -----
    function injectStyles() {
        const css = `
            #gm-video-speed-controller {
                position: fixed;
                bottom: 16px;
                right: 16px;
                z-index: 999999;
                background: rgba(0, 0, 0, 0.9);
                color: #fff;
                padding: 8px;
                border-radius: 6px;
                font-family: sans-serif;
                font-size: 12px;
                display: none; /* hidden by default */
                gap: 6px;
                align-items: center;
                opacity: 0;
                transition: opacity ${FADE_DURATION_MS}ms ease-out;
            }
            #gm-video-speed-controller.gm-visible {
                opacity: 1;
            }
            #gm-video-speed-controller .gm-btn {
                border: 1px solid rgba(255,255,255,0.6);
                padding: 2px 6px;
                border-radius: 3px;
                cursor: pointer;
                user-select: none;
                min-width: 24px;
                text-align: center;
            }
            #gm-video-speed-controller .gm-btn:hover {
                background: rgba(255,255,255,0.2);
            }
        `;
        if (typeof GM_addStyle === 'function') {
            GM_addStyle(css);
        } else {
            const style = document.createElement('style');
            style.textContent = css;
            document.head.appendChild(style);
        }
    }

    function createController() {
        if (controllerBox) return controllerBox;

        injectStyles();

        controllerBox = document.createElement('div');
        controllerBox.id = 'gm-video-speed-controller';

        const label = document.createElement('span');
        label.textContent = 'Speed:';

        const btnLabels = ['<<', '<', 'set', '>', '>>'];
        const buttons = {};

        btnLabels.forEach(text => {
            const b = document.createElement('div');
            b.className = 'gm-btn';
            b.textContent = text;
            buttons[text] = b;
            controllerBox.appendChild(b);
        });

        controllerBox.insertBefore(label, controllerBox.firstChild);

        buttons['<<'].addEventListener('click', () => {
            if (!currentVideo) return;
            bigStepDown(currentVideo);
            showOverlay();
        });

        buttons['<'].addEventListener('click', () => {
            if (!currentVideo) return;
            smallStepDown(currentVideo);
            showOverlay();
        });

        buttons['set'].addEventListener('click', () => {
            if (!currentVideo) return;
            setToDefault(currentVideo);
            showOverlay();
        });

        buttons['>'].addEventListener('click', () => {
            if (!currentVideo) return;
            smallStepUp(currentVideo);
            showOverlay();
        });

        buttons['>>'].addEventListener('click', () => {
            if (!currentVideo) return;
            bigStepUp(currentVideo);
            showOverlay();
        });

        setButton = buttons['set'];

        document.body.appendChild(controllerBox);
        updateSetButtonLabel();
        return controllerBox;
    }

    function updateSetButtonLabel() {
        if (!setButton) return;
        let speed = 1.0;
        if (currentVideo) {
            speed = currentVideo.playbackRate || 1.0;
        }
        const rounded = roundToTwoDecimals(speed).toFixed(2);
        setButton.textContent = `${rounded}x`;
    }

    // ----- Video tracking -----
    function markVideoActive(video) {
        currentVideo = video;
        if (!video.hasAttribute('tabindex')) {
            video.setAttribute('tabindex', '0');
        }
        updateSetButtonLabel();
        showOverlay();
    }

    function attachToVideo(video) {
        if (video.__gmSpeedAttached) return;
        video.__gmSpeedAttached = true;

        videoElements.add(video);

        video.addEventListener('click', () => markVideoActive(video));
        video.addEventListener('focus', () => markVideoActive(video));
        video.addEventListener('playing', () => markVideoActive(video));
        video.addEventListener('ratechange', () => {
            if (currentVideo === video) {
                updateSetButtonLabel();
            }
        });

        if (!currentVideo) {
            markVideoActive(video);
        }
    }

    function scanForVideos() {
        const videos = document.querySelectorAll('video');
        videos.forEach(v => attachToVideo(v));
    }

    // ----- Keyboard shortcuts -----
    window.addEventListener('keydown', function(e) {
        if (!currentVideo) return;

        const target = e.target;
        const tag = target && target.tagName ? target.tagName.toLowerCase() : '';
        if (['input', 'textarea', 'select'].includes(tag) || target.isContentEditable) {
            return;
        }

        const active = document.activeElement;
        const overlayHasFocus = controllerBox && controllerBox.contains(active);
        const videoHasFocus = (active === currentVideo);
        // If you want strictly "video in focus", uncomment:
        // if (!videoHasFocus && !overlayHasFocus) return;

        let handled = false;
        switch (e.key) {
            case 'S':
                bigStepDown(currentVideo);
                handled = true;
                break;
            case 's':
                smallStepDown(currentVideo);
                handled = true;
                break;
            case 'o':
                setToDefault(currentVideo);
                handled = true;
                break;
            case 'd':
                smallStepUp(currentVideo);
                handled = true;
                break;
            case 'D':
                bigStepUp(currentVideo);
                handled = true;
                break;
            case 'v':
                // toggle oscillation
                if (oscillationActive) {
                    stopOscillation();
                } else {
                    startOscillation();
                }
                handled = true;
                break;
        }

        if (handled) {
            e.preventDefault();
            e.stopPropagation();
            showOverlay();
        }
    }, true);

    // ----- Global mousemove: overlay + video geometry -----
    window.addEventListener('mousemove', function(e) {
        const x = e.clientX;
        const y = e.clientY;

        // 1) overlay hover
        let inOverlay = false;
        if (controllerBox && controllerBox.style.display !== 'none') {
            const orect = controllerBox.getBoundingClientRect();
            if (
                x >= orect.left &&
                x <= orect.right &&
                y >= orect.top &&
                y <= orect.bottom
            ) {
                inOverlay = true;
            }
        }

        if (inOverlay) {
            if (!overlayHover) {
                overlayHover = true;
                if (hideTimeout) {
                    clearTimeout(hideTimeout);
                    hideTimeout = null;
                }
                if (finalHideTimeout) {
                    clearTimeout(finalHideTimeout);
                    finalHideTimeout = null;
                }
                controllerBox.style.display = 'flex';
                controllerBox.classList.add('gm-visible');
            }
            return;
        } else {
            if (overlayHover) {
                overlayHover = false;
                showOverlay();
            }
        }

        // 2) video hover
        if (videoElements.size === 0) return;

        let hoveredVideo = null;
        for (const v of videoElements) {
            const rect = v.getBoundingClientRect();
            if (
                x >= rect.left &&
                x <= rect.right &&
                y >= rect.top &&
                y <= rect.bottom
            ) {
                hoveredVideo = v;
                break;
            }
        }

        if (!hoveredVideo) return;

        markVideoActive(hoveredVideo);
    }, true);

    // ----- Startup -----
    createController();
    scanForVideos();
    showOverlay();

    const observer = new MutationObserver(() => scanForVideos());
    observer.observe(document.documentElement || document.body, {
        childList: true,
        subtree: true
    });
})();
