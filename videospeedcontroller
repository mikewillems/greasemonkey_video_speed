// ==UserScript==
// @name         Video Speed Controls
// @namespace    http://github.com/mikewillems/greasemonkey_video_speed
// @version      0.6
// @description  Speed controller overlay with fade in/out on focus/changes or mouseover, for chosen sites (video + audio).
// @match        *://www.youtube.com/*
// @match        *://youtube.com/*
// @match        *://www.vimeo.com/*
// @match        *://vimeo.com/*
// @match        *://www.dailymotion.com/*
// @match        *://dailymotion.com/*
// @match        *://www.tiktok.com/*
// @match        *://tiktok.com/*
// @match        *://www.instagram.com/*
// @match        *://instagram.com/*
// @match        *://www.twitter.com/*
// @match        *://twitter.com/*
// @match        *://x.com/*
// @match        *://www.x.com/*
// @match        *://www.reddit.com/*
// @match        *://reddit.com/*
// @match        *://www.bilibili.com/*
// @match        *://bilibili.com/*
// @match        *://www.veoh.com/*
// @match        *://veoh.com/*
// @match        *://www.metacafe.com/*
// @match        *://metacafe.com/*
// @match        *://www.liveleak.com/*
// @match        *://liveleak.com/*
// @match        *://www.archive.org/*
// @match        *://archive.org/*
// @match        *://www.vidyard.com/*
// @match        *://vidyard.com/*
// @match        *://www.wistia.com/*
// @match        *://wistia.com/*
// @match        *://www.dtube.video/*
// @match        *://dtube.video/*
// @match        *://www.rumble.com/*
// @match        *://rumble.com/*
// @match        *://www.odyssey.com/*
// @match        *://odyssey.com/*
// @match        *://odysee.com/*
// @match        *://www.odysee.com/*
// @match        https://www.npr.org/*
// @run-at       document-end
// @grant        GM_addStyle
// ==/UserScript==

(function() {
    'use strict';

    console.log('[VideoSpeedCtrl] Script loaded on', window.location.href);

    // ----- Config -----
    const BIG_INCREMENTS = [0.125, 0.25, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];
    const SMALL_INC_RANGE = [0.1, 8.0];
    const SHOW_DURATION_MS = 1000;
    const FADE_DURATION_MS = 1000;

    // Breathe / oscillation timing (ms)
    const OSC_UP_MS = 5000;
    const OSC_HOLD_MAX_MS = 0;
    const OSC_DOWN_MS = 4000;
    const OSC_HOLD_MIN_MS = 1000;
    const OSC_TOTAL_MS = OSC_UP_MS + OSC_HOLD_MAX_MS + OSC_DOWN_MS + OSC_HOLD_MIN_MS;

    // ----- State -----
    /** @type {HTMLMediaElement|null} */
    let currentMedia = null;   // <video> or <audio>
    let controllerBox = null;
    let setButton = null;

    // overlay timers
    let hideTimeout = null;
    let finalHideTimeout = null;
    let overlayHover = false;

    // tracked media elements
    /** @type {Set<HTMLMediaElement>} */
    const mediaElements = new Set();

    // ----- Breathe / oscillation state -----
    let oscillationActive = false;      // user has breathe mode ON
    let oscillationPaused = false;      // temporarily paused due to user changing speed
    let oscillationTimer = null;
    let oscillationPauseTimeout = null;
    let oscillationStartTime = 0;

    let breatheAnchor = 1.0;            // user-configured speed for breathe mode
    let oscillationMin = 1.0;
    let oscillationMax = 2.0;

    // ----- Helpers -----
    function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
    }

    function roundToTwoDecimals(value) {
        return Math.round(value * 100) / 100;
    }

    function setPlaybackRate(media, rate) {
        let newRate = clamp(rate, SMALL_INC_RANGE[0], SMALL_INC_RANGE[1]);
        newRate = roundToTwoDecimals(newRate);
        media.playbackRate = newRate;
        updateSetButtonLabel();
    }

    function showOverlay() {
        if (!controllerBox) return;

        if (hideTimeout) {
            clearTimeout(hideTimeout);
            hideTimeout = null;
        }
        if (finalHideTimeout) {
            clearTimeout(finalHideTimeout);
            finalHideTimeout = null;
        }

        controllerBox.style.display = 'flex';
        // force reflow
        // eslint-disable-next-line no-unused-expressions
        controllerBox.offsetHeight;

        controllerBox.classList.add('gm-visible');

        // while hovering overlay, never auto-hide
        if (overlayHover) return;

        hideTimeout = setTimeout(() => {
            controllerBox.classList.remove('gm-visible');
            finalHideTimeout = setTimeout(() => {
                if (!controllerBox.classList.contains('gm-visible')) {
                    controllerBox.style.display = 'none';
                }
            }, FADE_DURATION_MS);
        }, SHOW_DURATION_MS);
    }

    // ----- Oscillation helpers -----
    function recomputeOscillationRangeFromAnchor() {
        oscillationMin = clamp(Math.min(breatheAnchor, 2.0), SMALL_INC_RANGE[0], SMALL_INC_RANGE[1]);
        oscillationMax = clamp(Math.max(breatheAnchor, 2.0), SMALL_INC_RANGE[0], SMALL_INC_RANGE[1]);
    }

    function ensureOscillationTimer() {
        if (!oscillationActive || oscillationPaused) return;
        if (oscillationTimer) return;
        oscillationStartTime = performance.now();
        oscillationTimer = setInterval(updateOscillation, 100);
    }

    function clearOscillationTimer() {
        if (oscillationTimer) {
            clearInterval(oscillationTimer);
            oscillationTimer = null;
        }
    }

    function cancelOscillation() {
        if (!oscillationActive) return;
        oscillationActive = false;
        oscillationPaused = false;
        clearOscillationTimer();
        if (oscillationPauseTimeout) {
            clearTimeout(oscillationPauseTimeout);
            oscillationPauseTimeout = null;
        }
    }

    function pauseOscillationForUserAdjust() {
        if (!oscillationActive) return;

        oscillationPaused = true;
        clearOscillationTimer();

        if (oscillationPauseTimeout) {
            clearTimeout(oscillationPauseTimeout);
        }

        oscillationPauseTimeout = setTimeout(() => {
            oscillationPauseTimeout = null;
            if (!oscillationActive) return;  // user canceled in the meantime
            oscillationPaused = false;
            ensureOscillationTimer();        // restart from a fresh cycle
        }, 1000); // 1 second pause after last user change
    }

    function startOscillation() {
        if (!currentMedia) return;

        const cur = currentMedia.playbackRate || 1.0;
        breatheAnchor = clamp(cur, SMALL_INC_RANGE[0], SMALL_INC_RANGE[1]);
        recomputeOscillationRangeFromAnchor();

        if (oscillationMin === oscillationMax) {
            // nothing to oscillate between
            return;
        }

        oscillationActive = true;
        oscillationPaused = false;
        if (oscillationPauseTimeout) {
            clearTimeout(oscillationPauseTimeout);
            oscillationPauseTimeout = null;
        }
        ensureOscillationTimer();
        showOverlay();
    }

    function updateOscillation() {
        if (!oscillationActive || oscillationPaused || !currentMedia) {
            clearOscillationTimer();
            return;
        }

        const now = performance.now();
        const elapsed = now - oscillationStartTime;
        let t = elapsed % OSC_TOTAL_MS;

        let rate;
        if (t < OSC_UP_MS) {
            // ramp up from min to max over 5s
            const f = t / OSC_UP_MS;
            rate = oscillationMin + (oscillationMax - oscillationMin) * f;
        } else if (t < OSC_UP_MS + OSC_HOLD_MAX_MS) {
            // hold max
            rate = oscillationMax;
        } else if (t < OSC_UP_MS + OSC_HOLD_MAX_MS + OSC_DOWN_MS) {
            // ramp down from max to min
            const tDown = t - (OSC_UP_MS + OSC_HOLD_MAX_MS);
            const f = tDown / OSC_DOWN_MS;
            rate = oscillationMax - (oscillationMax - oscillationMin) * f;
        } else {
            // hold min
            rate = oscillationMin;
        }

        setPlaybackRate(currentMedia, rate);
        // We intentionally don't re-show overlay every tick.
    }

    // When the user changes speed while breathe mode is active:
    // - Adjust anchor via the step logic
    // - Snap playback to anchor
    // - Pause oscillation for 1s, then resume.
    function applyUserRateChange(targetRate) {
        if (!currentMedia) return;

        if (oscillationActive) {
            breatheAnchor = clamp(targetRate, SMALL_INC_RANGE[0], SMALL_INC_RANGE[1]);
            recomputeOscillationRangeFromAnchor();
            setPlaybackRate(currentMedia, breatheAnchor);
            pauseOscillationForUserAdjust();
        } else {
            setPlaybackRate(currentMedia, targetRate);
        }
    }

    // ----- Step Logic (using anchor when oscillating) -----
    function getBaseSpeedForAdjust(media) {
        if (oscillationActive) {
            return breatheAnchor;
        }
        return (media.playbackRate || 1.0);
    }

    function bigStepDown(media) {
        const base = getBaseSpeedForAdjust(media);
        let target = base;
        for (let i = BIG_INCREMENTS.length - 1; i >= 0; i--) {
            if (BIG_INCREMENTS[i] < base) {
                target = BIG_INCREMENTS[i];
                break;
            }
        }
        applyUserRateChange(target);
    }

    function bigStepUp(media) {
        const base = getBaseSpeedForAdjust(media);
        let target = base;
        for (let i = 0; i < BIG_INCREMENTS.length; i++) {
            if (BIG_INCREMENTS[i] > base) {
                target = BIG_INCREMENTS[i];
                break;
            }
        }
        applyUserRateChange(target);
    }

    function smallStepDown(media) {
        const base = getBaseSpeedForAdjust(media);
        const min = SMALL_INC_RANGE[0];
        let target = Math.floor(base * 10 - 0.0001) / 10; // highest 0.1 multiple < base
        if (target < min) target = min;
        applyUserRateChange(target);
    }

    function smallStepUp(media) {
        const base = getBaseSpeedForAdjust(media);
        const max = SMALL_INC_RANGE[1];
        let target = Math.ceil(base * 10 + 0.0001) / 10; // lowest 0.1 multiple > base
        if (target > max) target = max;
        applyUserRateChange(target);
    }

    function setToDefault(media) {
        // 'o' / set button: cancel breathe mode and reset to 1.0
        cancelOscillation();
        setPlaybackRate(media, 1.0);
    }

    // ----- Controller UI -----
    function injectStyles() {
        const css = `
            #gm-video-speed-controller {
                position: fixed;
                bottom: 16px;
                right: 16px;
                z-index: 999999;
                background: rgba(0, 0, 0, 0.9);
                color: #fff;
                padding: 8px;
                border-radius: 6px;
                font-family: sans-serif;
                font-size: 12px;
                display: none; /* hidden by default */
                gap: 6px;
                align-items: center;
                opacity: 0;
                transition: opacity ${FADE_DURATION_MS}ms ease-out;
            }
            #gm-video-speed-controller.gm-visible {
                opacity: 1;
            }
            #gm-video-speed-controller .gm-btn {
                border: 1px solid rgba(255,255,255,0.6);
                padding: 2px 6px;
                border-radius: 3px;
                cursor: pointer;
                user-select: none;
                min-width: 24px;
                text-align: center;
            }
            #gm-video-speed-controller .gm-btn:hover {
                background: rgba(255,255,255,0.2);
            }
        `;
        if (typeof GM_addStyle === 'function') {
            GM_addStyle(css);
        } else {
            const style = document.createElement('style');
            style.textContent = css;
            document.head.appendChild(style);
        }
    }

    function createController() {
        if (controllerBox) return controllerBox;

        injectStyles();

        controllerBox = document.createElement('div');
        controllerBox.id = 'gm-video-speed-controller';

        const label = document.createElement('span');
        label.textContent = 'Speed:';

        const btnLabels = ['<<', '<', 'set', '>', '>>'];
        const buttons = {};

        btnLabels.forEach(text => {
            const b = document.createElement('div');
            b.className = 'gm-btn';
            b.textContent = text;
            buttons[text] = b;
            controllerBox.appendChild(b);
        });

        controllerBox.insertBefore(label, controllerBox.firstChild);

        buttons['<<'].addEventListener('click', () => {
            if (!currentMedia) return;
            bigStepDown(currentMedia);
            showOverlay();
        });

        buttons['<'].addEventListener('click', () => {
            if (!currentMedia) return;
            smallStepDown(currentMedia);
            showOverlay();
        });

        // center button: reset to 1.0 *and cancel breathe mode*
        buttons['set'].addEventListener('click', () => {
            if (!currentMedia) return;
            setToDefault(currentMedia);
            showOverlay();
        });

        buttons['>'].addEventListener('click', () => {
            if (!currentMedia) return;
            smallStepUp(currentMedia);
            showOverlay();
        });

        buttons['>>'].addEventListener('click', () => {
            if (!currentMedia) return;
            bigStepUp(currentMedia);
            showOverlay();
        });

        setButton = buttons['set'];

        document.body.appendChild(controllerBox);
        updateSetButtonLabel();
        return controllerBox;
    }

    function updateSetButtonLabel() {
        if (!setButton) return;
        let speed = 1.0;
        if (currentMedia) {
            speed = currentMedia.playbackRate || 1.0;
        }
        const rounded = roundToTwoDecimals(speed).toFixed(2);
        setButton.textContent = `${rounded}x`;
    }

    // ----- Media tracking (video + audio) -----
    function markMediaActive(media) {
        currentMedia = media;
        if (!media.hasAttribute('tabindex')) {
            media.setAttribute('tabindex', '0');
        }
        updateSetButtonLabel();
        showOverlay();
    }

    function attachToMedia(media) {
        if (media.__gmSpeedAttached) return;
        media.__gmSpeedAttached = true;

        mediaElements.add(media);

        media.addEventListener('click', () => markMediaActive(media));
        media.addEventListener('focus', () => markMediaActive(media));
        media.addEventListener('playing', () => markMediaActive(media));
        media.addEventListener('ratechange', () => {
            if (currentMedia === media) {
                updateSetButtonLabel();
            }
        });

        if (!currentMedia) {
            markMediaActive(media);
        }
    }

    function scanForMedia() {
        const nodes = document.querySelectorAll('video, audio');
        nodes.forEach(m => attachToMedia(m));
    }

    // ----- Keyboard shortcuts -----
    window.addEventListener('keydown', function(e) {
        if (!currentMedia) return;

        const target = e.target;
        const tag = target && target.tagName ? target.tagName.toLowerCase() : '';
        if (['input', 'textarea', 'select'].includes(tag) || target.isContentEditable) {
            return;
        }

        const active = document.activeElement;
        const overlayHasFocus = controllerBox && controllerBox.contains(active);
        const mediaHasFocus = (active === currentMedia);
        // If you want strictly "media in focus", uncomment:
        // if (!mediaHasFocus && !overlayHasFocus) return;

        let handled = false;
        switch (e.key) {
            case 'S': // big down
                bigStepDown(currentMedia);
                handled = true;
                break;
            case 's': // small down
                smallStepDown(currentMedia);
                handled = true;
                break;
            case 'o': // reset to 1.0 and cancel breathe mode
                setToDefault(currentMedia);
                handled = true;
                break;
            case 'd': // small up
                smallStepUp(currentMedia);
                handled = true;
                break;
            case 'D': // big up
                bigStepUp(currentMedia);
                handled = true;
                break;
            case 'v': // toggle breathe mode
                if (oscillationActive) {
                    cancelOscillation();
                } else {
                    startOscillation();
                }
                handled = true;
                break;
        }

        if (handled) {
            e.preventDefault();
            e.stopPropagation();
            showOverlay();
        }
    }, true);

    // ----- Global mousemove: overlay + media geometry -----
    window.addEventListener('mousemove', function(e) {
        const x = e.clientX;
        const y = e.clientY;

        // 1) overlay hover
        let inOverlay = false;
        if (controllerBox && controllerBox.style.display !== 'none') {
            const orect = controllerBox.getBoundingClientRect();
            if (
                x >= orect.left &&
                x <= orect.right &&
                y >= orect.top &&
                y <= orect.bottom
            ) {
                inOverlay = true;
            }
        }

        if (inOverlay) {
            if (!overlayHover) {
                overlayHover = true;
                if (hideTimeout) {
                    clearTimeout(hideTimeout);
                    hideTimeout = null;
                }
                if (finalHideTimeout) {
                    clearTimeout(finalHideTimeout);
                    finalHideTimeout = null;
                }
                controllerBox.style.display = 'flex';
                controllerBox.classList.add('gm-visible');
            }
            return;
        } else {
            if (overlayHover) {
                overlayHover = false;
                showOverlay();
            }
        }

        // 2) media hover (video or audio)
        if (mediaElements.size === 0) return;

        let hoveredMedia = null;
        for (const m of mediaElements) {
            const rect = m.getBoundingClientRect();
            if (
                x >= rect.left &&
                x <= rect.right &&
                y >= rect.top &&
                y <= rect.bottom
            ) {
                hoveredMedia = m;
                break;
            }
        }

        if (!hoveredMedia) return;
        markMediaActive(hoveredMedia);
    }, true);

    // ----- Startup -----
    createController();
    scanForMedia();
    showOverlay();

    const observer = new MutationObserver(() => scanForMedia());
    observer.observe(document.documentElement || document.body, {
        childList: true,
        subtree: true
    });
})();
